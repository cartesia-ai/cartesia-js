/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Cartesia from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as serializers from "../../../../serialization/index.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Agents {
    export interface Options {
        environment?: core.Supplier<environments.CartesiaEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the Cartesia-Version header */
        cartesiaVersion?: "2025-04-16";
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Cartesia-Version header */
        cartesiaVersion?: "2025-04-16";
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Agents {
    protected readonly _options: Agents.Options;

    constructor(_options: Agents.Options = {}) {
        this._options = _options;
    }

    /**
     * Lists all agents associated with your account.
     *
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.list()
     */
    public list(requestOptions?: Agents.RequestOptions): core.HttpResponsePromise<Cartesia.GetAgentsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__list(requestOptions));
    }

    private async __list(
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.GetAgentsResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                "/agents/",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.GetAgentsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the details of a specific agent. To create an agent, use the CLI or the Playground for the best experience and integration with Github.
     *
     * @param {string} agentId - The ID of the agent.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.get("agent_123")
     */
    public get(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.AgentSummary> {
        return core.HttpResponsePromise.fromPromise(this.__get(agentId, requestOptions));
    }

    private async __get(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.AgentSummary>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.AgentSummary.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/{agent_id}.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} agentId - The ID of the agent.
     * @param {Cartesia.UpdateAgentRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.update("agent_123", {
     *         ttsVoice: "bf0a246a-8642-498a-9950-80c35e9276b5",
     *         ttsLanguage: "en"
     *     })
     */
    public update(
        agentId: string,
        request: Cartesia.UpdateAgentRequest,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.AgentSummary> {
        return core.HttpResponsePromise.fromPromise(this.__update(agentId, request, requestOptions));
    }

    private async __update(
        agentId: string,
        request: Cartesia.UpdateAgentRequest,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.AgentSummary>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.UpdateAgentRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.AgentSummary.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling PATCH /agents/{agent_id}.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} agentId - The ID of the agent.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.delete("agent_id")
     */
    public delete(agentId: string, requestOptions?: Agents.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__delete(agentId, requestOptions));
    }

    private async __delete(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling DELETE /agents/{agent_id}.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List of public, Cartesia-provided agent templates to help you get started.
     *
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.templates()
     */
    public templates(requestOptions?: Agents.RequestOptions): core.HttpResponsePromise<Cartesia.GetTemplatesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__templates(requestOptions));
    }

    private async __templates(
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.GetTemplatesResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                "/agents/templates",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.GetTemplatesResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/templates.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Lists calls sorted by start time in descending order for a specific agent. `agent_id` is required and if you want to include `transcript` in the response, add `expand=transcript` to the request. This endpoint is paginated.
     *
     * @param {Cartesia.ListCallsRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.listCalls({
     *         agentId: "agent_id"
     *     })
     */
    public async listCalls(
        request: Cartesia.ListCallsRequest,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.Page<Cartesia.AgentCall>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (request: Cartesia.ListCallsRequest): Promise<core.WithRawResponse<Cartesia.GetCallsResponse>> => {
                const { agentId, expand, startingAfter, endingBefore, limit } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                _queryParams["agent_id"] = agentId;
                if (expand != null) {
                    _queryParams["expand"] = expand;
                }
                if (startingAfter != null) {
                    _queryParams["starting_after"] = startingAfter;
                }
                if (endingBefore != null) {
                    _queryParams["ending_before"] = endingBefore;
                }
                if (limit != null) {
                    _queryParams["limit"] = limit.toString();
                }
                let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    this._options?.headers,
                    mergeOnlyDefinedHeaders({
                        Authorization: await this._getAuthorizationHeader(),
                        "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
                    }),
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)) ??
                            environments.CartesiaEnvironment.Production,
                        "/agents/calls",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        data: serializers.GetCallsResponse.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    throw new errors.CartesiaError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.CartesiaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/calls.");
                    case "unknown":
                        throw new errors.CartesiaError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Pageable<Cartesia.GetCallsResponse, Cartesia.AgentCall>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) =>
                response?.nextPage != null && !(typeof response?.nextPage === "string" && response?.nextPage === ""),
            getItems: (response) => response?.data ?? [],
            loadPage: (response) => {
                return list(core.setObjectProperty(request, "startingAfter", response?.nextPage));
            },
        });
    }

    /**
     * @param {string} callId - The ID of the call.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.getCall("ac_abc123")
     */
    public getCall(
        callId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.AgentCall> {
        return core.HttpResponsePromise.fromPromise(this.__getCall(callId, requestOptions));
    }

    private async __getCall(
        callId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.AgentCall>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/calls/${encodeURIComponent(callId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.AgentCall.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/calls/{call_id}.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * The downloaded audio file is in .wav format. This endpoint streams the audio file content (WAV format) to the client.
     */
    public downloadCallAudio(
        callId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<core.BinaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__downloadCallAudio(callId, requestOptions));
    }

    private async __downloadCallAudio(
        callId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<core.BinaryResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)<core.BinaryResponse>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/calls/${encodeURIComponent(callId)}/audio`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "binary-response",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling GET /agents/calls/{call_id}/audio.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List the phone numbers associated with an agent. Currently, you can only have one phone number per agent and these are provisioned by Cartesia.
     *
     * @param {string} agentId - The ID of the agent.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.phoneNumbers("agent_demo")
     */
    public phoneNumbers(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.PhoneNumber[]> {
        return core.HttpResponsePromise.fromPromise(this.__phoneNumbers(agentId, requestOptions));
    }

    private async __phoneNumbers(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.PhoneNumber[]>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}/phone-numbers`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.agents.phoneNumbers.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling GET /agents/{agent_id}/phone-numbers.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List of all LLM-as-a-Judge metrics owned by your account.
     *
     * @param {Cartesia.ListMetricsRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.listMetrics()
     */
    public listMetrics(
        request: Cartesia.ListMetricsRequest = {},
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.ListMetricsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listMetrics(request, requestOptions));
    }

    private async __listMetrics(
        request: Cartesia.ListMetricsRequest = {},
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.ListMetricsResponse>> {
        const { startingAfter, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startingAfter != null) {
            _queryParams["starting_after"] = startingAfter;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                "/agents/metrics",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.ListMetricsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/metrics.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a metric by its ID.
     *
     * @param {string} metricId - The ID of the metric.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.getMetric("am_abc123")
     */
    public getMetric(
        metricId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.Metric> {
        return core.HttpResponsePromise.fromPromise(this.__getMetric(metricId, requestOptions));
    }

    private async __getMetric(
        metricId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.Metric>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/metrics/${encodeURIComponent(metricId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.Metric.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /agents/metrics/{metric_id}.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new metric.
     *
     * @param {Cartesia.CreateMetricRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.createMetric({
     *         name: "evaluate-user-satisfaction",
     *         displayName: "Evaluate User Satisfaction",
     *         prompt: "Task:\nEvaluate how engaged and satisfied the user is with the conversation. Engagement may be shown through active interest in the agent\u2019s products/services, expressing that the agent was helpful, or indicating they would want to interact again.\n\nDecision Logic:\n- If the user shows strong engagement (asks detailed follow-up questions, expresses high interest, compliments the agent, or states they would use the service/agent again) \u2192 classify as HIGH_SATISFACTION\n- If the user shows some engagement (asks a few relevant questions, shows mild interest, or gives neutral feedback) \u2192 classify as MEDIUM_SATISFACTION\n- If the user shows little or no engagement (short answers, off-topic responses, disinterest, no signs of satisfaction) \u2192 classify as LOW_SATISFACTION\n\nNotes:\n- Engagement can be verbal (explicit statements of interest) or behavioral (asking more about features, prices, benefits, or next steps).\n- Expressions of satisfaction, gratitude, or willingness to call again count as positive engagement.\n- Ignore scripted greetings or polite closings unless they contain genuine feedback.\n\nReturn:\nOnly output the exact category name as a string: HIGH_SATISFACTION, MEDIUM_SATISFACTION, or LOW_SATISFACTION.\n"
     *     })
     */
    public createMetric(
        request: Cartesia.CreateMetricRequest,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.Metric> {
        return core.HttpResponsePromise.fromPromise(this.__createMetric(request, requestOptions));
    }

    private async __createMetric(
        request: Cartesia.CreateMetricRequest,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.Metric>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                "/agents/metrics",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.CreateMetricRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.Metric.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /agents/metrics.");
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Paginated list of metric results. Filter results using the query parameters,
     *
     * @param {Cartesia.ListMetricResultsRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.listMetricResults()
     */
    public async listMetricResults(
        request: Cartesia.ListMetricResultsRequest = {},
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.Page<Cartesia.MetricResult>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Cartesia.ListMetricResultsRequest,
            ): Promise<core.WithRawResponse<Cartesia.ListMetricResultsResponse>> => {
                const { agentId, deploymentId, metricId, callId, startingAfter, endingBefore, limit } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (agentId != null) {
                    _queryParams["agent_id"] = agentId;
                }
                if (deploymentId != null) {
                    _queryParams["deployment_id"] = deploymentId;
                }
                if (metricId != null) {
                    _queryParams["metric_id"] = metricId;
                }
                if (callId != null) {
                    _queryParams["call_id"] = callId;
                }
                if (startingAfter != null) {
                    _queryParams["starting_after"] = startingAfter;
                }
                if (endingBefore != null) {
                    _queryParams["ending_before"] = endingBefore;
                }
                if (limit != null) {
                    _queryParams["limit"] = limit.toString();
                }
                let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    this._options?.headers,
                    mergeOnlyDefinedHeaders({
                        Authorization: await this._getAuthorizationHeader(),
                        "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
                    }),
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)) ??
                            environments.CartesiaEnvironment.Production,
                        "/agents/metrics/results",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        data: serializers.ListMetricResultsResponse.parseOrThrow(_response.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        }),
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    throw new errors.CartesiaError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.CartesiaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.CartesiaTimeoutError(
                            "Timeout exceeded when calling GET /agents/metrics/results.",
                        );
                    case "unknown":
                        throw new errors.CartesiaError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Pageable<Cartesia.ListMetricResultsResponse, Cartesia.MetricResult>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) =>
                response?.nextPage != null && !(typeof response?.nextPage === "string" && response?.nextPage === ""),
            getItems: (response) => response?.data ?? [],
            loadPage: (response) => {
                return list(core.setObjectProperty(request, "startingAfter", response?.nextPage));
            },
        });
    }

    /**
     * Export metric results to a CSV file. This endpoint is paginated with a default of 10 results per page and maximum of 100 results per page. Information on pagination can be found in the headers `x-has-more`, `x-limit`, and `x-next-page`.
     *
     * @param {Cartesia.ExportMetricResultsRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.exportMetricResults()
     */
    public exportMetricResults(
        request: Cartesia.ExportMetricResultsRequest = {},
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__exportMetricResults(request, requestOptions));
    }

    private async __exportMetricResults(
        request: Cartesia.ExportMetricResultsRequest = {},
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { agentId, deploymentId, metricId, callId, startingAfter, endingBefore, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (agentId != null) {
            _queryParams["agent_id"] = agentId;
        }

        if (deploymentId != null) {
            _queryParams["deployment_id"] = deploymentId;
        }

        if (metricId != null) {
            _queryParams["metric_id"] = metricId;
        }

        if (callId != null) {
            _queryParams["call_id"] = callId;
        }

        if (startingAfter != null) {
            _queryParams["starting_after"] = startingAfter;
        }

        if (endingBefore != null) {
            _queryParams["ending_before"] = endingBefore;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                "/agents/metrics/results/export",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling GET /agents/metrics/results/export.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Add a metric to an agent. Once the metric is added, it will be run on all calls made to the agent automatically from that point onwards.
     *
     * @param {string} agentId - The ID of the agent.
     * @param {string} metricId - The ID of the metric.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.addMetricToAgent("agent_id", "metric_id")
     */
    public addMetricToAgent(
        agentId: string,
        metricId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__addMetricToAgent(agentId, metricId, requestOptions));
    }

    private async __addMetricToAgent(
        agentId: string,
        metricId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}/metrics/${encodeURIComponent(metricId)}`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling POST /agents/{agent_id}/metrics/{metric_id}.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Remove a metric from an agent. Once the metric is removed, it will no longer be run on all calls made to the agent automatically from that point onwards. Existing metric results will remain.
     *
     * @param {string} agentId
     * @param {string} metricId - The ID of the metric.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.removeMetricFromAgent("agent_id", "metric_id")
     */
    public removeMetricFromAgent(
        agentId: string,
        metricId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__removeMetricFromAgent(agentId, metricId, requestOptions));
    }

    private async __removeMetricFromAgent(
        agentId: string,
        metricId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}/metrics/${encodeURIComponent(metricId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling DELETE /agents/{agent_id}/metrics/{metric_id}.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List of all deployments associated with an agent.
     *
     * @param {string} agentId - The ID of the agent.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.listDeployments("agent_demo")
     */
    public listDeployments(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.Deployment[]> {
        return core.HttpResponsePromise.fromPromise(this.__listDeployments(agentId, requestOptions));
    }

    private async __listDeployments(
        agentId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.Deployment[]>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/${encodeURIComponent(agentId)}/deployments`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.agents.listDeployments.Response.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling GET /agents/{agent_id}/deployments.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a deployment by its ID.
     *
     * @param {string} deploymentId - The ID of the deployment.
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.agents.getDeployment("ad_abc123")
     */
    public getDeployment(
        deploymentId: string,
        requestOptions?: Agents.RequestOptions,
    ): core.HttpResponsePromise<Cartesia.Deployment> {
        return core.HttpResponsePromise.fromPromise(this.__getDeployment(deploymentId, requestOptions));
    }

    private async __getDeployment(
        deploymentId: string,
        requestOptions?: Agents.RequestOptions,
    ): Promise<core.WithRawResponse<Cartesia.Deployment>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "Cartesia-Version": requestOptions?.cartesiaVersion ?? "2025-04-16",
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.CartesiaEnvironment.Production,
                `/agents/deployments/${encodeURIComponent(deploymentId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.Deployment.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CartesiaError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.CartesiaTimeoutError(
                    "Timeout exceeded when calling GET /agents/deployments/{deployment_id}.",
                );
            case "unknown":
                throw new errors.CartesiaError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = (await core.Supplier.get(this._options.token)) ?? process?.env["CARTESIA_API_KEY"];
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
